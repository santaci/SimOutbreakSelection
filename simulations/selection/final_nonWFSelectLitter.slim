// Selection-driven bottleneck

initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(keepPedigrees=T);
	initializeTreeSeq();
	defineConstant("simID", getSeed());
	if (exists("slimgui")) {
		//defineConstant("O", "nonWF_"+simID+".trees");
		defineConstant("O", "nonWF_select_"+simID+".trees");
		defineConstant("I", 1);
	}
	initializeMutationType("m1", 0.5, "f", 0.0);
	m1.convertToSubstitution = T;
	initializeGenomicElementType("g1", m1, 1.0);
	//initializeGenomicElement(g1, 0, 51304565);
	initializeGenomicElement(g1, 0, 99329961);
	initializeMutationRate(0);
	
	//Read HapMap genetic map for chr22
	//	lines = readFile("/home/users/cindy/genetic_map_GRCh37_chr22.txt");
	//	rates = NULL;
	//	ends = NULL;
	//	for (line in lines)
	//	{
	//		components = strsplit(line, "\t");
	//		if (components[0]=="Chromosome")
	//			next;
	//		ends = c(ends, asInteger(components[1]));
	//		rates = c(rates, asFloat(components[2]));
	//	}
	//	ends = c(ends[1:(size(ends)-1)] - 2, 51304565);
	//	rates = rates * 1e-8;
	//	initializeRecombinationRate(rates, ends);
	
	//Read combined HapMap for both chr21 and chr22
	
	lines = readFile("/home/users/cindy/recombination_map.TRANSPOSED.combined.txt");
	ends = asInteger(strsplit(lines[0]));
	rates = asFloat(strsplit(lines[1]));
	initializeRecombinationRate(rates, ends);
}


// WF-like reproduction - systematically returns to K and chooses a litter size from a poisson distribution
reproduction() {
	K = sim.getValue("K");
	for (i in seqLen(K))
	{
		firstParent = p2.sampleIndividuals(1);
		secondParent = p2.sampleIndividuals(1, exclude=firstParent);
		litterSize = rpois(1, 1.3);
		for (j in seqLen(litterSize))
			p2.addCrossed(firstParent, secondParent);
	}
	self.active = 0;
}

58000 early() {
	sim.readFromPopulationFile("/home/users/cindy/data/finalGravel_1897530535422.trees");
	sim.setValue("K", p2.individualCount);
	sim.setValue("N", p2.individualCount);
}

58000 late(){
	mut = sim.mutations;
	catn(mut);
}

// Non-overlapping generations
early()
{
	inds = sim.subpopulations.individuals;
	inds[inds.age > 0].fitnessScaling = 0.0;
	off = inds[inds.age < 1];
	writeFile("nwf_mated_parents_" + I + ".csv", paste(c(sim.generation,off.pedigreeParentIDs),"\t"), append=T);
	writeFile("nwf_mated_offspring_" + I + ".csv", paste(c(sim.generation,off.pedigreeID),"\t"), append=T);
	writeFile("nwf_mated_offspring_" + I + ".csv", paste(c(sim.generation+"g",off.countOfMutationsOfType(m1)),"\t"), append=T);

}

// Reduce fitness of individuals without the allele
58002:58005 early() {
	inds = sim.subpopulations.individuals;
	inds[inds.countOfMutationsOfType(m1)<2].fitnessScaling = 0.5;
	inds[inds.age > 0].fitnessScaling = 0.0;
}

// Positive selection is introduced
58002 early() {
	sim.mutations.setSelectionCoeff(0.0);
}

// Positive selection is turned off
58006 early() {
	sim.mutations.setSelectionCoeff(0.0);
}

// Output per generation - prints out to file the final parents of each remaining offspring
58000:58016 late() {
	sim.treeSeqRememberIndividuals(p2.individuals);
	freq = sim.mutationFrequencies(p2);
	inds = sim.subpopulations.individuals;
	off = inds[inds.age < 1];
	patsize = size(unique(off.pedigreeParentIDs));
	wt = size(inds[inds.countOfMutationsOfType(m1) == 0]);
	het = size(inds[inds.countOfMutationsOfType(m1) == 1]);
	hom = size(inds[inds.countOfMutationsOfType(m1) == 2]);
	catn(sim.generation + "\t" + p2.individualCount + "\t" + sim.mutationFrequencies(p2) + "\t" + wt + "\t" + het + "\t" + hom +  "\t" + mean(p2.cachedFitness(inds[inds.countOfMutationsOfType(m1) == 0].index)) + "\t" + mean(p2.cachedFitness(inds[inds.countOfMutationsOfType(m1) == 1].index)) + "\t" + mean(p2.cachedFitness(inds[inds.countOfMutationsOfType(m1) == 2].index)) + "\t" + patsize);
	writeFile("nwf_survivor_parents_" + I + ".csv", paste(c(sim.generation,off.pedigreeParentIDs),"\t"), append=T);
	writeFile("nwf_putparents_" + I + ".csv", paste(c(sim.generation+1,off.pedigreeID),"\t"), append=T);
	writeFile("nwf_putparents_" + I + ".csv", paste(c(sim.generation+1+"g",off.countOfMutationsOfType(m1)),"\t"), append=T);
	sim.setValue("K", size(off));
}

// Tree output
58005: late() {
	N = sim.getValue("N");
	K = sim.getValue("K");
	if (K >= N){
		catn("Reached recovery of population.");
		sim.simulationFinished();
		sim.treeSeqOutput("/home/users/cindy/data/nonWF_select_litter_" + I + ".trees");
	}
}
